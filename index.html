<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, viewport-fit=cover" />
  <title>Block Blast · 极简Ghost版（远离手指 / 松手就放）</title>
  <style>
    :root { --bg1:#fdfdfd; --bg2:#eef3fb; --grid:#c8d4e5; --cellEmpty:#e4eaf3; --ink:#102032; --ghostOk:rgba(102,166,255,.40); --ghostBad:rgba(239,91,91,.40); }
    html,body{margin:0;height:100%;background:var(--bg1);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--ink)}
    .wrap{max-width:480px;margin:auto;padding:16px}
    .header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
    .score{font-size:22px;font-weight:800;color:#3756c2}
    .sub{font-size:12px;opacity:.7}
    .btn,.toolbtn{border:0;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:700;font-size:14px;background:linear-gradient(145deg,#4e73df,#3756c2);color:#fff;box-shadow:0 4px 10px rgba(0,0,0,.15)}
    .toolbtn[disabled],.btn[disabled]{opacity:.4;cursor:not-allowed}
    canvas{width:100%;height:auto;display:block;background:var(--bg2);border-radius:20px;box-shadow:0 8px 24px rgba(0,0,0,.12);touch-action:auto;-webkit-user-select:none;user-select:none}
    .toolbar{display:flex;gap:8px;margin:10px 0 0;justify-content:center}
    .hint{margin-top:10px;font-size:13px;color:#4a5568;line-height:1.5}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div>
        <div class="score">分数: <span id="score">0</span> <span class="sub">(最佳 <span id="best">0</span>)</span></div>
        <div class="sub">连击: <span id="streak">0</span></div>
      </div>
      <button id="restart" class="btn">重开</button>
    </div>
    <canvas id="game" width="420" height="820"></canvas>
    <div class="toolbar">
      <button class="toolbtn" id="undoBtn" disabled>撤回</button>
    </div>
    <div class="hint">操作：手牌<strong>长按开始拖动</strong>（方块始终远离手指）、<strong>点击旋转</strong>；ghost 绿色=可放，<strong>松手即落</strong>；否则回手牌。</div>
  </div>

<script>
(function(){
  // —— 错误可视化（不使用 document.write，避免 write bug）——
  window.onerror = function(msg, src, lineno, colno, err){
    try{
      const c = document.getElementById('game'); if(!c) return;
      const x = c.getContext('2d'); if(!x) return;
      x.setTransform(1,0,0,1,0,0);
      x.fillStyle = 'rgba(0,0,0,0.65)';
      x.fillRect(0,0,c.width,c.height);
      x.fillStyle = '#fff';
      x.font = '14px monospace';
      const text = (msg||'Error') + '\n' + (err && err.stack ? err.stack : (src+':'+lineno+':'+colno));
      const lines = String(text).split('\n').slice(0,10);
      lines.forEach((line,i)=> x.fillText(line, 12, 24 + i*18));
    }catch(e){}
  };

  // ===== 常量 =====
  const BOARD_SIZE=10, GAP=2, HAND_AREA_H=260;
  const CANVAS_W=420, CANVAS_H=820;
  const CELL_SCORE=10, LINE_SCORE=100, MULT_PER_STREAK=0.1;
  const LONG_PRESS_MS=90; // <90ms 点击旋转；≥90ms 长按拖动
  const MOVE_SLOP=14;

  // ✅ 新增：手指→ghost 的“远离”偏移（固定 & 稳定，不抖动）
  //    手指实际触点到用于对齐棋盘的参考点之间，保持一个“较远”的距离
  const GHOST_FAR_OFFSET = { x: 0, y: 140 };

  // ✅ 新增：方块相对 ghost 的微小位移，保证“部分重叠而不是完全重合或太远”
  const PIECE_OVERLAP = { x: 3, y: 3 };

  const COLORS={ grid:'#c8d4e5', empty:'#e4eaf3', ghostOk: getCss('--ghostOk'), ghostBad:getCss('--ghostBad'), bgTop:'#ffffff', bgBottom:'#eef3fb' };
  const SHAPE_COLORS=[["#ff9a9e","#fad0c4"],["#a1c4fd","#c2e9fb"],["#fbc2eb","#a6c1ee"],["#ffecd2","#fcb69f"],["#ffdde1","#ee9ca7"],["#cfd9df","#e2ebf0"],["#d4fc79","#96e6a1"],["#84fab0","#8fd3f4"],["#fccb90","#d57eeb"],["#e0c3fc","#8ec5fc"]];
  function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name); }

  // ===== 画布 =====
  const cvs=document.getElementById('game');
  const ctx=cvs.getContext('2d');
  const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  function resize(){ cvs.width=CANVAS_W*dpr; cvs.height=CANVAS_H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); }
  resize(); addEventListener('resize', resize);

  // ===== 布局 =====
  const boardPixel=Math.min(CANVAS_W-32,32*BOARD_SIZE+GAP*(BOARD_SIZE+1));
  const cellSize=Math.floor((boardPixel-GAP*(BOARD_SIZE+1))/BOARD_SIZE);
  const boardW=cellSize*BOARD_SIZE+GAP*(BOARD_SIZE+1);
  const boardX=Math.floor((CANVAS_W-boardW)/2);
  const boardY=76; const boardH=boardW; const handY=boardY+boardH+16;

  // ===== 状态 =====
  let grid=Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
  let score=0, best=Number(localStorage.getItem('best')||0), streak=0;
  let hand=[]; // 3
  let dragging=null; // {piece,x,y,index,homeX,homeY,snapR,snapC,snapOK}
  let gameOver=false;
  let lastCleared=null, flashTimer=0;
  let returnAnim=null, spawnAnim=[null,null,null];
  const history=[]; const UNDO_LIMIT=20;

  // ===== 工具 =====
  const PIECES=[[[0,0]],[[0,0],[0,1]],[[0,0],[0,1],[0,2]],[[0,0],[0,1],[1,0],[1,1]],[[0,0],[1,0],[1,1]],[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]],[[0,0],[1,0],[2,0],[0,1],[1,1],[2,1]],[[0,0],[1,0],[1,1],[2,1]],[[0,1],[1,1],[1,0],[2,0]],[[0,0],[0,1],[0,2],[1,1]],[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]].map((cells,i)=>({id:i,cells:cells.map(([r,c])=>({r,c}))}));
  const isPiece=x=>!!(x&&Array.isArray(x.cells)&&x.cells.length>0);
  const clonePiece=p=>p?{id:p.id,cells:p.cells.map(({r,c})=>({r,c}))}:null;

  function bbox(piece){const rs=piece.cells.map(c=>c.r), cs=piece.cells.map(c=>c.c); const minR=Math.min(...rs), minC=Math.min(...cs), maxR=Math.max(...rs), maxC=Math.max(...cs); return {w:maxC-minC+1,h:maxR-minR+1,minR,minC};}
  function rotatePiece(p){ if(!isPiece(p)) return p; const rot=p.cells.map(({r,c})=>({r:c,c:-r})); const mr=Math.min(...rot.map(x=>x.r)), mc=Math.min(...rot.map(x=>x.c)); rot.forEach(x=>{x.r-=mr;x.c-=mc;}); return {id:p.id,cells:rot}; }

  const inBounds=(r,c)=>r>=0&&r<BOARD_SIZE&&c>=0&&c<BOARD_SIZE;
  function canPlace(piece,baseR,baseC){
    if(!isPiece(piece)) return false;
    for(const off of piece.cells){
      const r=baseR+off.r,c=baseC+off.c;
      if(!inBounds(r,c) || grid[r][c]!==0) return false;
    }
    return true;
  }
  function place(piece,baseR,baseC){ const val=piece.id+1; for(const off of piece.cells){ grid[baseR+off.r][baseC+off.c]=val; } }

  function clearLines(){ const rows=[],cols=[]; for(let r=0;r<BOARD_SIZE;r++){ if(grid[r].every(v=>v!==0)) rows.push(r);} for(let c=0;c<BOARD_SIZE;c++){ let full=true; for(let r=0;r<BOARD_SIZE;r++){ if(grid[r][c]===0){full=false;break;} } if(full) cols.push(c);} for(const r of rows){ for(let c=0;c<BOARD_SIZE;c++) grid[r][c]=0;} for(const c of cols){ for(let r=0;r<BOARD_SIZE;r++) grid[r][c]=0;} return {rows,cols}; }

  function anyPlacementPossible(pieces){ if(!Array.isArray(pieces)) return false;
    for(const p of pieces){ if(!isPiece(p)) continue;
      for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){ if(canPlace(p,r,c)) return true; }
    } return false;
  }

  function randPiece(){ return clonePiece(PIECES[Math.floor(Math.random()*PIECES.length)]); }
  function dealHand(){ for(let t=0;t<12;t++){ const h=[randPiece(),randPiece(),randPiece()]; if(anyPlacementPossible(h)) return h; } return [clonePiece(PIECES[0]),randPiece(),randPiece()]; }

  function calcGain(placedCells,rows,cols){ const base=placedCells*CELL_SCORE; const lines=rows+cols; const bonus=lines*LINE_SCORE+Math.max(0,lines-1)*50; const mult=1+Math.min(streak,5)*MULT_PER_STREAK; return Math.floor((base+bonus)*mult); }

  function updateHUD(){ qs('#score').textContent=score; qs('#best').textContent=best; qs('#streak').textContent=streak; qs('#undoBtn').disabled=history.length===0||gameOver; }
  function reset(){ grid=Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0)); score=0; streak=0; gameOver=false; hand=dealHand(); spawnAnim=[{t:0},{t:0},{t:0}]; dragging=null; lastCleared=null; flashTimer=0; history.length=0; updateHUD(); }

  function qs(sel){ return document.querySelector(sel); }

  // ===== 渲染 =====
  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }
  function fillTile(x,y,pair){ const g=ctx.createLinearGradient(x,y,x+cellSize,y+cellSize); g.addColorStop(0,pair[0]); g.addColorStop(1,pair[1]); ctx.fillStyle=g; roundRect(Math.round(x),Math.round(y),cellSize,cellSize,7); }

  function drawPieceAt(piece,px,py){ if(!isPiece(piece)) return; const pair=SHAPE_COLORS[piece.id%SHAPE_COLORS.length]; const minR=Math.min(...piece.cells.map(c=>c.r)),minC=Math.min(...piece.cells.map(c=>c.c)); for(const off of piece.cells){ const x=px+(off.c-minC)*(cellSize+GAP), y=py+(off.r-minR)*(cellSize+GAP); fillTile(x,y,pair); } }
  function drawPieceGrid(piece,baseR,baseC,color){ if(!isPiece(piece)) return; ctx.fillStyle=color; for(const off of piece.cells){ const r=baseR+off.r,c=baseC+off.c; const x=boardX+GAP+c*(cellSize+GAP), y=boardY+GAP+r*(cellSize+GAP); roundRect(x,y,cellSize,cellSize,7); } }

  function handSlotPose(i){ const slotW=Math.floor((CANVAS_W-32-2*16)/3); const sx=16+i*(slotW+16), sy=handY; return {x:sx+14,y:sy+16,scale:Math.min(1,(slotW-28)/(cellSize*3)),homeX:sx+14,homeY:sy+16,slotW}; }

  function isOverBoard(px,py){ return px>=boardX && px<=boardX+boardW && py>=boardY && py<=boardY+boardH; }
  function snapToBoard(px,py,piece){
    // 简单 ghost：把“参考点”映射到棋盘格（超出则 clamp 到边缘）
    const bb=bbox(piece);
    const relX=px-(boardX+GAP)+(bb.minC*(cellSize+GAP));
    const relY=py-(boardY+GAP)+(bb.minR*(cellSize+GAP));
    let c=Math.floor(relX/(cellSize+GAP));
    let r=Math.floor(relY/(cellSize+GAP));
    c=Math.max(0,Math.min(c,BOARD_SIZE-bb.w));
    r=Math.max(0,Math.min(r,BOARD_SIZE-bb.h));
    return {r,c};
  }

  // ===== 主循环 =====
  function draw(){
    // 背景 & 棋盘
    const bg=ctx.createLinearGradient(0,0,0,CANVAS_H); bg.addColorStop(0,COLORS.bgTop); bg.addColorStop(1,COLORS.bgBottom);
    ctx.fillStyle=bg; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
    ctx.fillStyle=COLORS.grid; roundRect(boardX,boardY,boardW,boardH,18);

    // 网格
    for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
      const x=boardX+GAP+c*(cellSize+GAP), y=boardY+GAP+r*(cellSize+GAP);
      if(grid[r][c]!==0){ const idx=grid[r][c]-1; fillTile(x,y, SHAPE_COLORS[idx%SHAPE_COLORS.length]); }
      else { ctx.fillStyle='#e4eaf3'; roundRect(x,y,cellSize,cellSize,7);}
    }

    // 手牌底板
    const slotW=Math.floor((CANVAS_W-32-2*16)/3);
    for(let i=0;i<3;i++){ const sx=16+i*(slotW+16), sy=handY; ctx.fillStyle='#e5ebf6'; roundRect(sx,sy,slotW,HAND_AREA_H-30,16); }

    // 手牌（非拖拽）
    for(let i=0;i<3;i++){
      const p=hand[i]; if(!isPiece(p)) continue;
      if(dragging && dragging.index===i) continue;
      const pose=handSlotPose(i); drawPieceAt(p,pose.x,pose.y);
    }

    // ghost + 实体（拖拽时）
    if(dragging && isPiece(dragging.piece)){
      // ✅ 关键：用“手指远离”的参考点（anchor）来计算 ghost 对齐
      const anchorX = dragging.x - GHOST_FAR_OFFSET.x;
      const anchorY = dragging.y - GHOST_FAR_OFFSET.y;

      const snap=snapToBoard(anchorX, anchorY, dragging.piece);
      const ok=canPlace(dragging.piece,snap.r,snap.c);
      drawPieceGrid(dragging.piece,snap.r,snap.c, ok?COLORS.ghostOk:COLORS.ghostBad);

      // ✅ 关键：方块基于 ghost 的格位再稍微位移，形成“近距离 + 部分重叠”
      const bb=bbox(dragging.piece);
      const minR=bb.minR, minC=bb.minC;
      const ghostX=boardX+GAP+snap.c*(cellSize+GAP)-minC*(cellSize+GAP);
      const ghostY=boardY+GAP+snap.r*(cellSize+GAP)-minR*(cellSize+GAP);

      // 方块位置 = ghost 原点 + 很小的固定偏移（不会过远，且保持部分重叠）
      const px = Math.round(ghostX + PIECE_OVERLAP.x);
      const py = Math.round(ghostY + PIECE_OVERLAP.y);
      drawPieceAt(dragging.piece, px, py);

      // 记录给松手判定（基于 ghost）
      dragging.snapR=snap.r; dragging.snapC=snap.c; dragging.snapOK=ok;
    }

    // game over 遮罩
    if(gameOver){
      ctx.fillStyle='rgba(0,0,0,.55)'; roundRect(40,boardY+boardH/2-60,CANVAS_W-80,120,16);
      ctx.fillStyle='#fff'; ctx.font='22px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('Game Over',CANVAS_W/2,boardY+boardH/2-8);
      ctx.font='14px system-ui'; ctx.fillText('点“重开”再来一局',CANVAS_W/2,boardY+boardH/2+18);
    }

    requestAnimationFrame(draw);
  }

  // ===== 交互：长按拖动 / 点击旋转（极简）=====
  function handHit(x,y){
    const slotW=Math.floor((CANVAS_W-32-2*16)/3);
    for(let i=0;i<3;i++){
      const sx=16+i*(slotW+16), sy=handY;
      if(x>=sx && x<=sx+slotW && y>=sy && y<=sy+HAND_AREA_H){
        const pose=handSlotPose(i); return {index:i,toX:pose.homeX,toY:pose.homeY};
      }
    } return null;
  }

  let pressTimer=null, pressStart=0, pressSlot=null, pressStartPos=null;
  function startPress(slot,p){ clearPress(); pressSlot=slot; pressStart=Date.now(); pressStartPos=p;
    pressTimer=setTimeout(()=>{ if(!pressSlot) return; beginDrag(slot,p); clearPress(); },LONG_PRESS_MS);
  }
  function clearPress(){ if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; } pressSlot=null; pressStart=0; pressStartPos=null; }
  function beginDrag(slot,p){ const i=slot.index; if(!isPiece(hand[i])) return; dragging={piece:clonePiece(hand[i]),x:p.x,y:p.y,index:i,homeX:slot.toX,homeY:slot.toY,snapR:0,snapC:0,snapOK:false}; }

  function getPos(evt){
    const r=cvs.getBoundingClientRect();
    let cx,cy;
    if(evt.touches&&evt.touches.length){ cx=evt.touches[0].clientX; cy=evt.touches[0].clientY; }
    else if(evt.changedTouches&&evt.changedTouches.length){ cx=evt.changedTouches[0].clientX; cy=evt.changedTouches[0].clientY; }
    else { cx=evt.clientX; cy=evt.clientY; }
    return { x: (cx-r.left)*(CANVAS_W/r.width), y: (cy-r.top)*(CANVAS_H/r.height) };
  }

  function onDown(evt){ if(gameOver) return; const p=getPos(evt); const slot=handHit(p.x,p.y);
    if(slot){ startPress(slot,p); addDocDrag(); if(evt.cancelable) evt.preventDefault(); } }
  function onMove(evt){ const p=getPos(evt);
    if(pressSlot && pressStart){
      const dt=Date.now()-pressStart;
      if(dt>=LONG_PRESS_MS){ beginDrag(pressSlot,p); clearPress(); }
      else if(Math.hypot(p.x-pressStartPos.x,p.y-pressStartPos.y) > MOVE_SLOP){ clearPress(); }
    }
    if(dragging){ dragging.x=Math.round(p.x); dragging.y=Math.round(p.y); if(evt.cancelable) evt.preventDefault(); }
  }
  function onUp(evt){
    const p=getPos(evt);
    if(dragging){
      // 极简：ghost 绿色->放；红色->回手牌
      if(dragging.snapOK){
        pushHistory();
        place(dragging.piece, dragging.snapR, dragging.snapC);
        const cleared=clearLines();
        const gain=calcGain(dragging.piece.cells.length,cleared.rows.length,cleared.cols.length);
        score+=gain; streak = (cleared.rows.length+cleared.cols.length>0) ? (streak+1) : 0;
        hand[dragging.index]=randPiece();
        dragging=null;
        if(!anyPlacementPossible(hand)){ gameOver=true; best=Math.max(best,score); localStorage.setItem('best',String(best)); }
        updateHUD();
      }else{
        // 回手牌（瞬移，避免任何视觉抖动）
        dragging=null;
      }
      if(evt.cancelable) evt.preventDefault(); removeDocDrag(); return;
    }
    // 点击旋转
    if(pressSlot && Date.now()-pressStart < LONG_PRESS_MS){
      const i=pressSlot.index; if(isPiece(hand[i])) hand[i]=rotatePiece(hand[i]);
      updateHUD();
    }
    clearPress(); removeDocDrag();
  }

  function pushHistory(){ const snapshot={ grid:grid.map(r=>r.slice()), score, streak, hand:hand.map(clonePiece) }; history.push(snapshot); if(history.length>UNDO_LIMIT) history.shift(); qs('#undoBtn').disabled=false; }
  function undo(){ if(history.length===0) return; const s=history.pop(); grid=s.grid.map(r=>r.slice()); score=s.score; streak=s.streak; hand=s.hand.map(clonePiece); gameOver=false; dragging=null; updateHUD(); if(history.length===0) qs('#undoBtn').disabled=true; }

  // 事件绑定
  cvs.addEventListener('mousedown', onDown);
  cvs.addEventListener('mousemove', onMove);
  addEventListener('mouseup', onUp);

  cvs.addEventListener('touchstart', onDown, {passive:false});
  cvs.addEventListener('touchmove', onMove, {passive:false});
  cvs.addEventListener('touchend', onUp, {passive:false});
  cvs.addEventListener('touchcancel', onUp, {passive:false});

  function addDocDrag(){ document.addEventListener('mousemove', onMove, {passive:false}); document.addEventListener('mouseup', onUp, {passive:false}); document.addEventListener('touchmove', onMove, {passive:false}); document.addEventListener('touchend', onUp, {passive:false}); }
  function removeDocDrag(){ document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', onUp); }

  // 控件
  qs('#restart').addEventListener('click', reset);
  qs('#undoBtn').addEventListener('click', undo);

  // ===== 自检（不改动原有逻辑）=====
  (function tests(){
    const ok=n=>console.log('%c✓ '+n,'color:#2e7d32'); const ng=(n,e)=>console.error('%c✗ '+n,'color:#b00020',e);
    const assert=(n,f)=>{try{if(!f()) throw 0; ok(n);}catch(e){ng(n,e);}};
    hand=dealHand(); assert('initial 3 pieces', ()=> hand.filter(isPiece).length===3);
    const key=p=>p.cells.map(({r,c})=>r+','+c).sort().join('|');
    const a=clonePiece(PIECES[9]); let b=rotatePiece(a); b=rotatePiece(b); b=rotatePiece(b); b=rotatePiece(b);
    assert('rotate x4 same', ()=> key(a)===key(b));
    const g0=grid.map(r=>r.slice()); pushHistory(); grid[0][0]=1; undo();
    assert('undo restores grid', ()=> JSON.stringify(grid)===JSON.stringify(g0));
  })();

    reset(); requestAnimationFrame(draw);
})();
</script>

<script>
// PWA 注册（v14）
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try { const regs = await navigator.serviceWorker.getRegistrations(); await Promise.all(regs.map(r => r.unregister().catch(()=>{}))); } catch(e) {}
    try { await navigator.serviceWorker.register('./sw-v14.js', {scope: './'}); } catch(e) { console.warn('SW register failed', e); }
  });
}
</script>
</body>
</html>
