<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, viewport-fit=cover" />
  <title>Block Blast · 极简Ghost版（全屏移动 / 边界容差修复 / 回位动画 / 渐隐消除）</title>
  <style>
    :root {
      --bg1:#fdfdfd;
      --bg2:#eef3fb;
      --grid:#b7c6e3;           /* 稍深的网格描边，提高对比 */
      --cellEmpty:#f2f7ff;      /* 更清晰的空格底色 */
      --ink:#102032;
      --ghostOk:rgba(102,166,255,.40);
      --ghostBad:rgba(239,91,91,.40);
    }
    html,body{margin:0;height:100%;background:var(--bg1);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--ink)}
    .wrap{max-width:480px;margin:auto;padding:16px}
    .header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
    .score{font-size:22px;font-weight:800;color:#3756c2}
    .sub{font-size:12px;opacity:.7}
    .btn,.toolbtn{border:0;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:700;font-size:14px;background:linear-gradient(145deg,#4e73df,#3756c2);color:#fff;box-shadow:0 4px 10px rgba(0,0,0,.15)}
    .toolbtn[disabled],.btn[disabled]{opacity:.4;cursor:not-allowed}
    canvas{width:100%;height:auto;display:block;background:var(--bg2);border-radius:20px;box-shadow:0 8px 24px rgba(0,0,0,.12);touch-action:auto;-webkit-user-select:none;user-select:none}
    .toolbar{display:flex;gap:8px;margin:10px 0 0;justify-content:center}
    .hint{margin-top:10px;font-size:13px;color:#4a5568;line-height:1.5}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div>
        <div class="score">分数: <span id="score">0</span> <span class="sub">(最佳 <span id="best">0</span>)</span></div>
        <div class="sub">连击: <span id="streak">0</span></div>
      </div>
      <button id="restart" class="btn">重开</button>
    </div>
    <canvas id="game" width="420" height="820"></canvas>
    <div class="toolbar">
      <button class="toolbtn" id="undoBtn" disabled>撤回</button>
    </div>
    <div class="hint">操作：手牌<strong>长按开始拖动</strong>（远离手指、1:1 跟手）、<strong>点击旋转</strong>；可在<strong>整个屏幕</strong>移动；ghost 绿色=可放，<strong>松手即落</strong>；否则<strong>自动回位</strong>；明显下滑<strong>取消</strong>；消除行/列<strong>线性渐隐</strong>。</div>
  </div>

<script>
(function(){
  // —— 错误可视化（避免 write bug）——
  window.onerror = function(msg, src, lineno, colno, err){
    try{
      const c = document.getElementById('game'); if(!c) return;
      const x = c.getContext('2d'); if(!x) return;
      x.setTransform(1,0,0,1,0,0);
      x.fillStyle = 'rgba(0,0,0,0.65)';
      x.fillRect(0,0,c.width,c.height);
      x.fillStyle = '#fff';
      x.font = '14px monospace';
      const text = (msg||'Error') + '\n' + (err && err.stack ? err.stack : (src+':'+lineno+':'+colno));
      const lines = String(text).split('\n').slice(0,10);
      lines.forEach((line,i)=> x.fillText(line, 12, 24 + i*18));
    }catch(e){}
  };

  // ===== 常量 =====
  const BOARD_SIZE=10, GAP=2, HAND_AREA_H=260;
  const CANVAS_W=420, CANVAS_H=820;
  const CELL_SCORE=10, LINE_SCORE=100, MULT_PER_STREAK=0.1;
  const LONG_PRESS_MS=90; // <90ms 点击旋转；≥90ms 长按拖动
  const MOVE_SLOP=14;

  // 偏移与动画
  const GHOST_FAR_OFFSET = { x: 0, y: 140 }; // 锚点（用于对齐）相对手指的偏移
  const FREE_MOVE_OFFSET = { x: 0, y: 84 };  // 自由移动时方块相对手指的可见偏移
  const PIECE_OVERLAP = { x: 10, y: 10 };    // 与 ghost 的微重叠

  // 下滑取消
  const CANCEL_ZONE_Y = CANVAS_H * 0.60;
  const CANCEL_DRAG_DY = 160;
  const CANCEL_ANIM_MS = 140;
  const CANCEL_HINT_H = 110;

  // 渐隐消除（线性）
  const CLEAR_FADE_MS = 220;

  // ✅ 边界容差（修复上边界 ghost 偶发不显示）
  const EPS = 30e-1;

  const COLORS={
    grid:getCss('--grid'),
    empty:getCss('--cellEmpty'),
    ghostOk:getCss('--ghostOk'),
    ghostBad:getCss('--ghostBad'),
    bgTop:'#ffffff',
    bgBottom:'#eef3fb'
  };
  const SHAPE_COLORS=[
    ["#ff9a9e","#fad0c4"],["#a1c4fd","#c2e9fb"],["#fbc2eb","#a6c1ee"],
    ["#ffecd2","#fcb69f"],["#ffdde1","#ee9ca7"],["#cfd9df","#e2ebf0"],
    ["#d4fc79","#96e6a1"],["#84fab0","#8fd3f4"],["#fccb90","#d57eeb"],["#e0c3fc","#8ec5fc"]
  ];
  function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name); }

  // ===== 画布 =====
  const cvs=document.getElementById('game');
  const ctx=cvs.getContext('2d');
  const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  function resize(){ cvs.width=CANVAS_W*dpr; cvs.height=CANVAS_H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); }
  resize(); addEventListener('resize', resize);

  // ===== 布局 =====
  const boardPixel=Math.min(CANVAS_W-32,32*BOARD_SIZE+GAP*(BOARD_SIZE+1));
  const cellSize=Math.floor((boardPixel-GAP*(BOARD_SIZE+1))/BOARD_SIZE);
  const boardW=cellSize*BOARD_SIZE+GAP*(BOARD_SIZE+1);
  const boardX=Math.floor((CANVAS_W-boardW)/2);
  const boardY=76; const boardH=boardW; const handY=boardY+boardH+16;

  // ===== 状态 =====
  let grid=Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
  let score=0, best=Number(localStorage.getItem('best')||0), streak=0;
  let hand=[]; // 3
  // dragging: {piece,x,y,index,homeX,homeY,snapR,snapC,snapOK,startY,startedAt}
  let dragging=null;
  let gameOver=false;
  let returnAnim=null; // {t0,dur,fromX,fromY,toX,toY,piece}
  const history=[]; const UNDO_LIMIT=20;
  let clearAnim=null; // {t0,dur, rows, cols}

  // ===== 工具 =====
  const PIECES=[[[0,0]],[[0,0],[0,1]],[[0,0],[0,1],[0,2]],[[0,0],[0,1],[1,0],[1,1]],[[0,0],[1,0],[1,1]],[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]],[[0,0],[1,0],[2,0],[0,1],[1,1],[2,1]],[[0,0],[1,0],[1,1],[2,1]],[[0,1],[1,1],[1,0],[2,0]],[[0,0],[0,1],[0,2],[1,1]],[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]].map((cells,i)=>({id:i,cells:cells.map(([r,c])=>({r,c}))}));
  const isPiece=x=>!!(x&&Array.isArray(x.cells)&&x.cells.length>0);
  const clonePiece=p=>p?{id:p.id,cells:p.cells.map(({r,c})=>({r,c}))}:null;

  function bbox(piece){const rs=piece.cells.map(c=>c.r), cs=piece.cells.map(c=>c.c); const minR=Math.min(...rs), minC=Math.min(...cs), maxR=Math.max(...rs), maxC=Math.max(...cs); return {w:maxC-minC+1,h:maxR-minR+1,minR,minC};}
  function rotatePiece(p){ if(!isPiece(p)) return p; const rot=p.cells.map(({r,c})=>({r:c,c:-r})); const mr=Math.min(...rot.map(x=>x.r)), mc=Math.min(...rot.map(x=>x.c)); rot.forEach(x=>{x.r-=mr;x.c-=mc;}); return {id:p.id,cells:rot}; }

  const inBounds=(r,c)=>r>=0&&r<BOARD_SIZE&&c>=0&&c<BOARD_SIZE;
  function canPlace(piece,baseR,baseC){
    if(!isPiece(piece)) return false;
    for(const off of piece.cells){
      const r=baseR+off.r,c=baseC+off.c;
      if(!inBounds(r,c) || grid[r][c]!==0) return false;
    }
    return true;
  }
  function place(piece,baseR,baseC){ const val=piece.id+1; for(const off of piece.cells){ grid[baseR+off.r][baseC+off.c]=val; } }

  function findFullLines(){
    const rows=[], cols=[];
    for(let r=0;r<BOARD_SIZE;r++){ if(grid[r].every(v=>v!==0)) rows.push(r); }
    for(let c=0;c<BOARD_SIZE;c++){ let full=true; for(let r=0;r<BOARD_SIZE;r++){ if(grid[r][c]===0){ full=false; break; } } if(full) cols.push(c); }
    return {rows, cols};
  }
  function applyClearLines(rows, cols){
    for(const r of rows){ for(let c=0;c<BOARD_SIZE;c++) grid[r][c]=0; }
    for(const c of cols){ for(let r=0;r<BOARD_SIZE;r++) grid[r][c]=0; }
  }
  function anyPlacementPossible(pieces){
    for(const p of pieces){ if(!isPiece(p)) continue;
      for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){ if(canPlace(p,r,c)) return true; }
    } return false;
  }
  function randPiece(){ return clonePiece(PIECES[Math.floor(Math.random()*PIECES.length)]); }
  function dealHand(){ for(let t=0;t<12;t++){ const h=[randPiece(),randPiece(),randPiece()]; if(anyPlacementPossible(h)) return h; } return [clonePiece(PIECES[0]),randPiece(),randPiece()]; }

  function calcGain(placedCells,rows,cols){ const base=placedCells*CELL_SCORE; const lines=rows+cols; const bonus=lines*LINE_SCORE+Math.max(0,lines-1)*50; const mult=1+Math.min(streak,5)*MULT_PER_STREAK; return Math.floor((base+bonus)*mult); }

  function updateHUD(){ qs('#score').textContent=score; qs('#best').textContent=best; qs('#streak').textContent=streak; qs('#undoBtn').disabled=history.length===0||gameOver; }
  function reset(){ grid=Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0)); score=0; streak=0; gameOver=false; hand=dealHand(); dragging=null; clearAnim=null; returnAnim=null; history.length=0; updateHUD(); }
  function qs(sel){ return document.querySelector(sel); }

  // ===== 绘制基础 =====
  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }
  function fillTile(x,y,pair){ const g=ctx.createLinearGradient(x,y,x+cellSize,y+cellSize); g.addColorStop(0,pair[0]); g.addColorStop(1,pair[1]); ctx.fillStyle=g; roundRect(Math.round(x),Math.round(y),cellSize,cellSize,7); }

  function drawTileCell(r,c,alphaOverride=null){
    const x=boardX+GAP+c*(cellSize+GAP), y=boardY+GAP+r*(cellSize+GAP);
    const idx=grid[r][c]-1;
    const pair=SHAPE_COLORS[(idx)%SHAPE_COLORS.length];
    const saveAlpha=ctx.globalAlpha;
    if(alphaOverride!=null) ctx.globalAlpha = Math.max(0, Math.min(1, alphaOverride));
    fillTile(x,y,pair);
    ctx.globalAlpha=saveAlpha;
  }

  function drawPieceAt(piece,px,py){
    if(!isPiece(piece)) return;
    const pair=SHAPE_COLORS[piece.id%SHAPE_COLORS.length];
    const minR=Math.min(...piece.cells.map(c=>c.r)),minC=Math.min(...piece.cells.map(c=>c.c));
    for(const off of piece.cells){
      const x=px+(off.c-minC)*(cellSize+GAP), y=py+(off.r-minR)*(cellSize+GAP);
      fillTile(x,y,pair);
    }
  }
  function drawPieceGrid(piece,baseR,baseC,color){
    if(!isPiece(piece)) return; ctx.fillStyle=color;
    for(const off of piece.cells){
      const r=baseR+off.r,c=baseC+off.c;
      const x=boardX+GAP+c*(cellSize+GAP), y=boardY+GAP+r*(cellSize+GAP);
      roundRect(x,y,cellSize,cellSize,7);
    }
  }

  function handSlotPose(i){ const slotW=Math.floor((CANVAS_W-32-2*16)/3); const sx=16+i*(slotW+16), sy=handY; return {x:sx+14,y:sy+16,scale:Math.min(1,(slotW-28)/(cellSize*3)),homeX:sx+14,homeY:sy+16,slotW}; }

  // ---------- 关键修复：连续坐标 + EPS 容差 ----------
  // 原先用 Math.floor 后判断边界，浮点误差会让刚回到上边界时 r=-1。
  // 现在先用连续坐标判断是否在可放范围，再在需要对齐时 floor+clamp。
  function rawSnapContinuous(anchorX, anchorY, piece){
    const bb=bbox(piece);
    const relX=anchorX-(boardX+GAP)+(bb.minC*(cellSize+GAP));
    const relY=anchorY-(boardY+GAP)+(bb.minR*(cellSize+GAP));
    const cF = relX/(cellSize+GAP);
    const rF = relY/(cellSize+GAP);
    return {rF,cF,bb};
  }
  function isAnchorInBoard(anchorX, anchorY, piece){
    const {rF,cF,bb}=rawSnapContinuous(anchorX, anchorY, piece);
    return (rF >= -EPS) && (cF >= -EPS)
        && (rF <= BOARD_SIZE - bb.h + EPS)
        && (cF <= BOARD_SIZE - bb.w + EPS);
  }
  function snapToBoard(anchorX, anchorY, piece){
    const {rF,cF,bb}=rawSnapContinuous(anchorX, anchorY, piece);
    let r=Math.floor(rF + EPS);
    let c=Math.floor(cF + EPS);
    r=Math.max(0,Math.min(r,BOARD_SIZE-bb.h));
    c=Math.max(0,Math.min(c,BOARD_SIZE-bb.w));
    return {r,c};
  }
  // ----------------------------------------------------

  function currentPiecePixel(d){
    const anchorX = d.x - GHOST_FAR_OFFSET.x;
    const anchorY = d.y - GHOST_FAR_OFFSET.y;
    if(isAnchorInBoard(anchorX,anchorY,d.piece)){
      const bb=bbox(d.piece); const minR=bb.minR, minC=bb.minC;
      const snap=snapToBoard(anchorX, anchorY, d.piece);
      const ghostX=boardX+GAP+snap.c*(cellSize+GAP)-minC*(cellSize+GAP);
      const ghostY=boardY+GAP+snap.r*(cellSize+GAP)-minR*(cellSize+GAP);
      return { px: Math.round(ghostX + PIECE_OVERLAP.x), py: Math.round(ghostY + PIECE_OVERLAP.y) };
    }else{
      return { px: d.x - FREE_MOVE_OFFSET.x, py: d.y - FREE_MOVE_OFFSET.y };
    }
  }

  // ===== 主循环 =====
  function draw(){
    // 背景 & 棋盘
    const bg=ctx.createLinearGradient(0,0,0,CANVAS_H); bg.addColorStop(0,COLORS.bgTop); bg.addColorStop(1,COLORS.bgBottom);
    ctx.fillStyle=bg; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
    ctx.fillStyle=COLORS.grid; roundRect(boardX,boardY,boardW,boardH,18);

    // 网格（含渐隐消除）
    let fadeAlpha=null, fading=false, fadeRows=[], fadeCols=[];
    if(clearAnim){
      const p = Math.min(1, (performance.now()-clearAnim.t0)/clearAnim.dur);
      fadeAlpha = 1 - p; fading = true;
      fadeRows = clearAnim.rows; fadeCols = clearAnim.cols;
      if(p>=1){ applyClearLines(clearAnim.rows, clearAnim.cols); clearAnim = null; }
    }

    for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
      const x=boardX+GAP+c*(cellSize+GAP), y=boardY+GAP+r*(cellSize+GAP);
      if(grid[r][c]!==0){
        let a=null;
        if(fading && (fadeRows.includes(r) || fadeCols.includes(c))) a=fadeAlpha;
        drawTileCell(r,c,a);
      }else{
        ctx.fillStyle=COLORS.empty;
        roundRect(x,y,cellSize,cellSize,7);
      }
    }

    // 手牌底板
    const slotW=Math.floor((CANVAS_W-32-2*16)/3);
    for(let i=0;i<3;i++){ const sx=16+i*(slotW+16), sy=handY; ctx.fillStyle='#e5ebf6'; roundRect(sx,sy,slotW,HAND_AREA_H-30,16); }

    // 手牌（非拖拽）
    for(let i=0;i<3;i++){
      const p=hand[i]; if(!isPiece(p)) continue;
      if(dragging && dragging.index===i) continue;
      const pose=handSlotPose(i); drawPieceAt(p,pose.x,pose.y);
    }

    // 下滑取消提示带（拖拽/回位动画期间展示）
    const showCancelBar = !!dragging || !!returnAnim;
    if(showCancelBar){
      const barY = CANVAS_H - CANCEL_HINT_H;
      const highlight = dragging && (dragging.y >= CANCEL_ZONE_Y) && (dragging.y - dragging.startY >= CANCEL_DRAG_DY);
      ctx.globalAlpha = highlight ? 0.95 : 0.55;
      ctx.fillStyle = 'rgba(20,24,44,0.80)';
      roundRect(20, barY, CANVAS_W-40, CANCEL_HINT_H-14, 16);
      ctx.fillStyle = '#fff';
      ctx.font = '14px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('继续下滑以取消并回手牌', CANVAS_W/2, barY + (CANCEL_HINT_H-14)/2);
      ctx.globalAlpha = 1;
    }

    // 拖拽时：在“可放范围内”才显示 ghost & 可落子；否则自由移动
    if(dragging && isPiece(dragging.piece)){
      const anchorX = dragging.x - GHOST_FAR_OFFSET.x;
      const anchorY = dragging.y - GHOST_FAR_OFFSET.y;
      const inBoard = isAnchorInBoard(anchorX, anchorY, dragging.piece);

      if(inBoard){
        const snap=snapToBoard(anchorX, anchorY, dragging.piece);
        const ok=canPlace(dragging.piece,snap.r,snap.c);
        const bb=bbox(dragging.piece);
        const minR=bb.minR, minC=bb.minC;
        const ghostX=boardX+GAP+snap.c*(cellSize+GAP)-minC*(cellSize+GAP);
        const ghostY=boardY+GAP+snap.r*(cellSize+GAP)-minR*(cellSize+GAP);

        const meetsCancel = (dragging.y >= CANCEL_ZONE_Y) && ((dragging.y - dragging.startY) >= CANCEL_DRAG_DY);
        if(!meetsCancel){
          drawPieceGrid(dragging.piece,snap.r,snap.c, ok?COLORS.ghostOk:COLORS.ghostBad);
        }

        const px = Math.round(ghostX + PIECE_OVERLAP.x);
        const py = Math.round(ghostY + PIECE_OVERLAP.y);
        drawPieceAt(dragging.piece, px, py);

        dragging.snapR=snap.r; dragging.snapC=snap.c; dragging.snapOK=ok;
      }else{
        const px = dragging.x - FREE_MOVE_OFFSET.x;
        const py = dragging.y - FREE_MOVE_OFFSET.y;
        drawPieceAt(dragging.piece, px, py);
        dragging.snapOK=false;
      }
    }

    // 回位动画
    if(returnAnim){
      const now = performance.now();
      const t = Math.min(1, (now - returnAnim.t0) / returnAnim.dur);
      const ease = 1 - Math.pow(1 - t, 3); // easeOutCubic
      const x = returnAnim.fromX + (returnAnim.toX - returnAnim.fromX) * ease;
      const y = returnAnim.fromY + (returnAnim.toY - returnAnim.fromY) * ease;
      drawPieceAt(returnAnim.piece, x, y);
      if(t >= 1){ returnAnim = null; }
    }

    // game over 遮罩
    if(gameOver){
      ctx.fillStyle='rgba(0,0,0,.55)'; roundRect(40,boardY+boardH/2-60,CANVAS_W-80,120,16);
      ctx.fillStyle='#fff'; ctx.font='22px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('Game Over',CANVAS_W/2,boardY+boardH/2-8);
      ctx.font='14px system-ui'; ctx.fillText('点“重开”再来一局',CANVAS_W/2,boardY+boardH/2+18);
    }

    requestAnimationFrame(draw);
  }

  // ===== 交互：长按拖动 / 点击旋转 =====
  function handHit(x,y){
    const slotW=Math.floor((CANVAS_W-32-2*16)/3);
    for(let i=0;i<3;i++){
      const sx=16+i*(slotW+16), sy=handY;
      if(x>=sx && x<=sx+slotW && y>=sy && y<=sy+HAND_AREA_H){
        const pose=handSlotPose(i); return {index:i,toX:pose.homeX,toY:pose.homeY};
      }
    } return null;
  }

  let pressTimer=null, pressStart=0, pressSlot=null, pressStartPos=null;
  function startPress(slot,p){ clearPress(); pressSlot=slot; pressStart=Date.now(); pressStartPos=p;
    pressTimer=setTimeout(()=>{ if(!pressSlot) return; beginDrag(slot,p); clearPress(); },LONG_PRESS_MS);
  }
  function clearPress(){ if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; } pressSlot=null; pressStart=0; pressStartPos=null; }
  function beginDrag(slot,p){
    const i=slot.index; if(!isPiece(hand[i])) return;
    dragging={
      piece:clonePiece(hand[i]),
      x:p.x, y:p.y, index:i,
      homeX:slot.toX, homeY:slot.toY,
      snapR:0,snapC:0,snapOK:false,
      startY:p.y,
      startedAt:performance.now()
    };
  }

  function getPos(evt){
    const r=cvs.getBoundingClientRect();
    let cx,cy;
    if(evt.touches&&evt.touches.length){ cx=evt.touches[0].clientX; cy=evt.touches[0].clientY; }
    else if(evt.changedTouches&&evt.changedTouches.length){ cx=evt.changedTouches[0].clientX; cy=evt.changedTouches[0].clientY; }
    else { cx=evt.clientX; cy=evt.clientY; }
    return { x: (cx-r.left)*(CANVAS_W/r.width), y: (cy-r.top)*(CANVAS_H/r.height) };
  }

  function startReturnToHome(pieceState){
    const i = pieceState.index;
    const home = handSlotPose(i);
    const {px,py} = currentPiecePixel(pieceState);
    returnAnim = {
      t0: performance.now(), dur: CANCEL_ANIM_MS,
      fromX: px, fromY: py, toX: home.homeX, toY: home.homeY,
      piece: clonePiece(pieceState.piece)
    };
  }

  function triggerCancel(){
    if(!dragging) return;
    startReturnToHome(dragging);
    dragging = null;
  }

  function onDown(evt){ if(gameOver || returnAnim) return; const p=getPos(evt); const slot=handHit(p.x,p.y);
    if(slot){ startPress(slot,p); addDocDrag(); if(evt.cancelable) evt.preventDefault(); } }
  function onMove(evt){
    const p=getPos(evt);
    if(pressSlot && pressStart){
      const dt=Date.now()-pressStart;
      if(dt>=LONG_PRESS_MS){ beginDrag(pressSlot,p); clearPress(); }
      else if(Math.hypot(p.x-pressStartPos.x,p.y-pressStartPos.y) > MOVE_SLOP){ clearPress(); }
    }
    if(dragging){
      dragging.x = p.x; dragging.y = p.y;
      if(dragging.y >= CANCEL_ZONE_Y && (dragging.y - dragging.startY) >= CANCEL_DRAG_DY){
        triggerCancel();
      }
      if(evt.cancelable) evt.preventDefault();
    }
  }
  function onUp(evt){
    if(returnAnim){ removeDocDrag(); return; }
    const p=getPos(evt);
    if(dragging){
      if(dragging.snapOK){
        pushHistory();
        place(dragging.piece, dragging.snapR, dragging.snapC);

        const {rows, cols} = findFullLines();
        const gain=calcGain(dragging.piece.cells.length, rows.length, cols.length);
        score+=gain;
        streak = (rows.length+cols.length>0) ? (streak+1) : 0;

        if(rows.length || cols.length){
          clearAnim = { t0: performance.now(), dur: CLEAR_FADE_MS, rows: rows.slice(), cols: cols.slice() };
        }

        hand[dragging.index]=randPiece();
        dragging=null;
        if(!anyPlacementPossible(hand)){ gameOver=true; best=Math.max(best,score); localStorage.setItem('best',String(best)); }
        updateHUD();
      }else{
        startReturnToHome(dragging); // 未放置成功则回位
        dragging=null;
      }
      if(evt.cancelable) evt.preventDefault(); removeDocDrag(); return;
    }
    if(pressSlot && Date.now()-pressStart < LONG_PRESS_MS){
      const i=pressSlot.index; if(isPiece(hand[i])) hand[i]=rotatePiece(hand[i]);
      updateHUD();
    }
    clearPress(); removeDocDrag();
  }

  function pushHistory(){ const snapshot={ grid:grid.map(r=>r.slice()), score, streak, hand:hand.map(clonePiece) }; history.push(snapshot); if(history.length>UNDO_LIMIT) history.shift(); qs('#undoBtn').disabled=false; }
  function undo(){ if(history.length===0 || returnAnim) return; const s=history.pop(); grid=s.grid.map(r=>r.slice()); score=s.score; streak=s.streak; hand=s.hand.map(clonePiece); gameOver=false; dragging=null; clearAnim=null; updateHUD(); if(history.length===0) qs('#undoBtn').disabled=true; }

  // 事件绑定
  cvs.addEventListener('mousedown', onDown);
  cvs.addEventListener('mousemove', onMove);
  addEventListener('mouseup', onUp);

  cvs.addEventListener('touchstart', onDown, {passive:false});
  cvs.addEventListener('touchmove', onMove, {passive:false});
  cvs.addEventListener('touchend', onUp, {passive:false});
  cvs.addEventListener('touchcancel', onUp, {passive:false});

  function addDocDrag(){ document.addEventListener('mousemove', onMove, {passive:false}); document.addEventListener('mouseup', onUp, {passive:false}); document.addEventListener('touchmove', onMove, {passive:false}); document.addEventListener('touchend', onUp, {passive:false}); }
  function removeDocDrag(){ document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', onUp); }

  // 控件
  qs('#restart').addEventListener('click', reset);
  qs('#undoBtn').addEventListener('click', undo);

  // ===== 自检 =====
  (function tests(){
    const ok=n=>console.log('%c✓ '+n,'color:#2e7d32'); const ng=(n,e)=>console.error('%c✗ '+n,'color:#b00020',e);
    const assert=(n,f)=>{try{if(!f()) throw 0; ok(n);}catch(e){ng(n,e);}};
    hand=dealHand(); assert('initial 3 pieces', ()=> hand.filter(isPiece).length===3);
    const key=p=>p.cells.map(({r,c})=>r+','+c).sort().join('|');
    const a=clonePiece(PIECES[9]); let b=rotatePiece(a); b=rotatePiece(b); b=rotatePiece(b); b=rotatePiece(b);
    assert('rotate x4 same', ()=> key(a)===key(b));
    const g0=grid.map(r=>r.slice()); pushHistory(); grid[0][0]=1; undo();
    assert('undo restores grid', ()=> JSON.stringify(grid)===JSON.stringify(g0));
  })();

  reset(); requestAnimationFrame(draw);
})();
</script>

<script>
// PWA 注册（v14）
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try { const regs = await navigator.serviceWorker.getRegistrations(); await Promise.all(regs.map(r => r.unregister().catch(()=>{}))); } catch(e) {}
    try { await navigator.serviceWorker.register('./sw-v14.js', {scope: './'}); } catch(e) { console.warn('SW register failed', e); }
  });
}
</script>
</body>
</html>
